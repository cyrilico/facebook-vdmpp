class User
types
  public String = seq1 of char;
values
instance variables
  protected user: User; --Keep a self reference for invariant usage (self is not recognised in that scope)
  protected name: String;
  public friends: set of User;
  protected blocked: set of User;
  protected posts: seq of Publication;
  protected chats: inmap String to GroupChat;
  
  -- No self friendship nor self blocking
  inv user not in set friends and user not in set blocked;
  
  -- Friendship is bidirectional
  inv forall friend in set friends & user in set friend.friends;
  
  -- No friends can on the blocked list
  inv blocked inter friends = {};
  
  -- All of user's posts must be of his authorship
  -- Same as forall ... getAuthor=user
  inv not exists publication in seq posts & publication.getAuthor() <> user; 
  
  -- User is a member in all of the group chats he has stored
  inv forall chat in set rng chats & user in set chat.getMembers();
operations
  public User: String ==> User
      User(userName) == (
        name := userName;
        friends := {};
        blocked := {};
        posts := [];
        chats := {|->};
        user := self;
        return self;
      )
      pre userName <> ""
      post name = userName and friends = {} and posts = [];
  
  pure public getName: () ==> String
      getName() == return name
      post RESULT = name;
  
  pure public getChats: () ==> set of GroupChat
  		getChats() == return rng chats
  		post forall chat in set RESULT & chat.getName() in set dom chats;
  
  pure public getChatByName: String ==> GroupChat
  		getChatByName(chatName) == return chats(chatName);
  
  pure public getPublications: User ==> seq of Publication
  		getPublications(searcher) == (
  			return [posts(i) | i in set inds posts & posts(i).userHasPermissions(searcher)]
  		);
  		
  pure public getFriends: () ==> set of User
      getFriends() == return friends
      post RESULT = friends;
  
  pure public getBlockedUsers: () ==> set of User
  		getBlockedUsers() == return blocked
  		post RESULT = blocked;
  
  pure public getFriendsOfFriends: () ==> set of User
  		getFriendsOfFriends() == (
  			-- Union of friends set with every other friends set from user's friends. Then, exclude itself
  			return {people | people in set friends union dunion {friend.friends | friend in set friends} \ {user} } 
  		)
  		post friends subset RESULT and card RESULT >= card friends;
  
  pure public getFriendsTransitiveClosure: () ==> set of User
			getFriendsTransitiveClosure() ==  (
				dcl closure : set of User := friends;
				dcl visited : set of User := {}; 
				while visited <> closure do 
					let t in set (closure \ visited) in (
					closure := closure union t.friends;
					visited := visited union {t}
					);
				return closure \ {user}
			)
			post friends subset RESULT and card RESULT >= card friends;
			
	public nameContains: String ==> bool
			nameContains(string) == (
				--seq of char instead of string because, if not found, can eventually become empty string
				--and String is defined as seq1 of char
				dcl userName: seq of char := name;
				
				while userName <> "" do (
					if userName(1,...,len string) = string
					then return true
					else userName := tl userName
				);
				
				return false
			);
	
	public makePublication: Publication`String * Publication`Date * Publication`Permissions ==> ()
			makePublication(content, timestamp, permissions) == (
				posts := [new Publication(self, content, timestamp, permissions)] ^ posts
			)
			pre len posts > 0 => timestamp >= posts(1).getTimestamp()
			post len posts = len posts~ + 1;
	
	public updatePublicationPermissions: nat1 * Publication`Permissions ==> ()
			updatePublicationPermissions(publicationId, newPermissions) == (
				let index = iota i in set inds posts & posts(i).getId() = publicationId in posts(index).updatePermissions(newPermissions)
			)
			pre exists1 index in set inds posts & posts(index).getId() = publicationId;
	
	public deletePublication: nat1 ==> ()
			deletePublication(publicationId) == (
				posts := [posts(i) | i in set inds posts & posts(i).getId() <> publicationId]
			)
			pre exists1 index in set inds posts & posts(index).getId() = publicationId
			post not exists index in set inds posts & posts(index).getId() = publicationId;
	
	-- When user creates chat
	public createGroupChat: String * set of User ==> ()
			createGroupChat(chatName, initialMembers) == (
				--let expression so group chat reference is the same for all users
				let newChat = new GroupChat(chatName, initialMembers union {self}) in (
					chats := chats munion {chatName |-> newChat};
					for all member in set initialMembers do
						member.addGroupChat(newChat);
					)
			)
			pre chatName not in set dom chats and initialMembers subset friends
			post chatName in set dom chats;
	
	-- When user is added to an existing chat
	protected addGroupChat: GroupChat ==> ()
			addGroupChat(chat) == (
				chat.addMember(self);
				chats := chats munion {chat.getName() |-> chat};
			)
			pre chat.getName() not in set dom chats
			post chat.getName() in set dom chats;
	
	public addFriendToChat: User * String ==> ()
			addFriendToChat(friend, chatName) == (
				friend.addGroupChat(chats(chatName))
			)
			pre friend in set friends and chatName in set dom chats and not exists cName in set {chat.getName() | chat in set friend.getChats()} & cName = chatName
			post exists1 cName in set {chat.getName() | chat in set friend.getChats()} & cName = chatName;
	
	public leaveGroupChat: String ==> ()
			leaveGroupChat(chatName) == (
				chats(chatName).removeMember(self);
				chats := {chatName} <-: chats;
			)
			pre chatName in set dom chats
			post chatName not in set dom chats;
	
	public sendChatMessage: String * ChatMessage`String * ChatMessage`Date ==> ()
			sendChatMessage(chatName, content, timestamp) == (
				chats(chatName).sendMessage(new ChatMessage(user, content, timestamp));
			)
			pre chatName in set dom chats;
	
	public searchTextInChat: String * String ==> seq of ChatMessage
			searchTextInChat(chatName, searchText) == (
				return chats(chatName).getMessagesWithText(searchText);
			)
			pre chatName in set dom chats;
	
	public filterDateInChat: String * [Date] * [Date] ==> seq of ChatMessage
			filterDateInChat(chatName, beginningDate, endDate) == (
				return chats(chatName).getMessagesBetween(beginningDate, endDate);
			)
			pre chatName in set dom chats;
	
	public blockUser: User ==> ()
			blockUser(userBlocked) == (
				blocked := blocked union {userBlocked};
			)
			post card blocked = card blocked~ + 1;
	
	public unblockUser: User ==> ()
			unblockUser(userBlocked) == (
				blocked := blocked \ {userBlocked};
			)
			pre userBlocked in set blocked;
	
functions
traces
end User